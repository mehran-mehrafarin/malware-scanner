package com.sdase.malwarescanner.web.rest;

import com.sdase.malwarescanner.config.Constants;
import com.sdase.malwarescanner.config.StorageProperties;
import com.sdase.malwarescanner.dto.FileRequestDTO;
import com.sdase.malwarescanner.dto.FileResponseDTO;
import com.sdase.malwarescanner.exception.FileDownloadException;
import com.sdase.malwarescanner.exception.ResourceNotFoundException;
import com.sdase.malwarescanner.exception.StorageException;
import com.sdase.malwarescanner.service.FileService;
import com.sdase.malwarescanner.web.model.ExceptionModel;
import com.sdase.malwarescanner.web.model.UploadResponseModel;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;

@RestController
@RequestMapping(Constants.FILE_REST_PATH)
public class FileRest {


    private final Path rootLocation;

    private FileService service;

    public FileRest(StorageProperties properties, FileService service) {
        this.service = service;
        this.rootLocation = Paths.get(properties.getLocation());
    }

    @PostMapping(Constants.FILE_REST_UPLOAD_PATH)
    public UploadResponseModel upload(@RequestParam("file") MultipartFile file) {

        securityCheck(file);
        service.add(file);

        String fileName = StringUtils.cleanPath(file.getOriginalFilename());

        return new UploadResponseModel("File successfully uploaded.", fileName);
    }

    @GetMapping(Constants.FILE_REST_CHECK_DOWNLOAD_PATH)
    public ResponseEntity<Resource> downloadForChecking(@PathVariable(name = "code") String code, @RequestParam("checkName") String checkName) {

        FileRequestDTO requestDTO = new FileRequestDTO().setCode(code).setCheckName(checkName);

        FileResponseDTO responseDTO = service.getForChecking(requestDTO);

        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(responseDTO.getContentType()))
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + responseDTO.getPublicFileName() + "\"")
                .body(responseDTO.getResource());
    }

    @GetMapping(Constants.FILE_REST_DOWNLOAD_PATH)
    public ResponseEntity<Resource> downloadForConsuming(@PathVariable(name = "code") String code) {

        FileResponseDTO responseDTO = service.getForConsuming(code);

        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(responseDTO.getContentType()))
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + responseDTO.getOriginalFileName() + "\"")
                .body(responseDTO.getResource());
    }


    private void securityCheck(MultipartFile file) {

        String fileName = StringUtils.cleanPath(file.getOriginalFilename());
        Path destinationFilePath = this.rootLocation.resolve(Paths.get(fileName)).normalize().toAbsolutePath();

        if (fileName.contains(".."))
            throw new StorageException("Filename contains invalid path sequence " + fileName);

        if (!destinationFilePath.getParent().equals(this.rootLocation.toAbsolutePath()))
            throw new StorageException("Cannot store file outside current directory.");
    }

    @ExceptionHandler({ResourceNotFoundException.class, FileDownloadException.class, StorageException.class})
    public ResponseEntity<?> handleResourceNotFound(RuntimeException exc) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ExceptionModel(LocalDateTime.now(), exc.getMessage()));
    }
}
