package com.sdase.malwarescanner.service.impl;


import com.sdase.malwarescanner.config.UserPrincipal;
import com.sdase.malwarescanner.entity.Role;
import com.sdase.malwarescanner.entity.User;
import com.sdase.malwarescanner.exception.ResourceNotFoundException;
import com.sdase.malwarescanner.exception.SignUpException;
import com.sdase.malwarescanner.repository.RoleRepository;
import com.sdase.malwarescanner.repository.UserRepository;
import com.sdase.malwarescanner.service.UserService;
import com.sdase.malwarescanner.web.model.RoleModel;
import com.sdase.malwarescanner.web.model.UserModel;
import com.sdase.malwarescanner.web.model.UserRequestModel;
import com.sdase.malwarescanner.web.model.UserResponseModel;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import static com.sdase.malwarescanner.util.UUIDUtil.getUUID;


@Service
@Transactional
public class UserServiceImpl implements UserService {

    private UserRepository repository;

    private RoleRepository roleRepository;

    private PasswordEncoder passwordEncoder;

    private ModelMapper modelMapper;

    public UserServiceImpl(UserRepository repository, RoleRepository roleRepository, PasswordEncoder passwordEncoder, ModelMapper modelMapper) {
        this.repository = repository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.modelMapper = modelMapper;
    }

    @Override
    public User getCurrentUser() {
        UserPrincipal principal = (UserPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        return repository.findByUsername(principal.getUsername())
                .orElseThrow(() -> new UsernameNotFoundException("User name not found - " + principal.getUsername()));
    }

    @Override
    public UserResponseModel getByCode(String code) {

        User entity = repository.findByCode(code).orElseThrow(() -> new ResourceNotFoundException("User not found."));

        UserModel model = modelMapper.map(entity, UserModel.class);

        UserResponseModel response = new UserResponseModel();
        response.setModel(model);
        response.setHttpStatus(HttpStatus.OK);

        return response;
    }

    @Override
    public UserResponseModel getPaginated(UserRequestModel request) {
        Pageable pageable = PageRequest.of(request.getPage(), request.getSize(), Sort.by("id").descending());

        Page<User> page = repository.findAll(pageable);

        List<UserModel> models = page.getContent().stream().map(e -> modelMapper.map(e, UserModel.class)).collect(Collectors.toList());

        UserResponseModel response = new UserResponseModel();
        response.setModels(models);
        response.setHttpStatus(HttpStatus.OK);

        return response;
    }

    @Override
    public UserResponseModel add(UserModel model) {

        if (repository.findByUsername(model.getUsername()).isPresent())
            throw new SignUpException("This username has already been registered pleases provide another one");

        Collection<Role> roles = addToleToUser(model.getRoleCodes());

        User user = modelMapper.map(model, User.class);
        user.setRoles(roles);
        user.setCode(getUUID());
        user.setPassword(passwordEncoder.encode(model._getPassword()));
        user.setCreatedDate(LocalDate.now());
        repository.save(user);

        Collection<RoleModel> roleModels = roles.stream().map(e -> modelMapper.map(e, RoleModel.class)).collect(Collectors.toList());

        model.setCode(user.getCode());
        model.setCreatedDate(user.getCreatedDate().toString());
        model.setRoles(roleModels);
        model.setPassword(null);

        UserModel userModel = modelMapper.map(model, UserModel.class);

        UserResponseModel response = new UserResponseModel();
        response.setHttpStatus(HttpStatus.CREATED);
        response.setMessage("User created successfully.");
        response.setModel(userModel);

        return response;
    }

    @Override
    public UserResponseModel signUp(UserModel model) {

        if (repository.findByUsername(model.getUsername()).isPresent())
            throw new SignUpException("This username has already been registered pleases provide another one");

        Role role = roleRepository.findByName("ROLE_USER");
        Collection<Role> roles = new ArrayList<>();
        roles.add(role);

        User user = modelMapper.map(model, User.class);
        user.setRoles(roles);
        user.setCode(getUUID());
        user.setPassword(passwordEncoder.encode(model._getPassword()));
        user.setState(User.State.ENABLE);
        user.setCreatedDate(LocalDate.now());
        repository.save(user);

        Collection<RoleModel> roleModels = roles.stream().map(e -> modelMapper.map(e, RoleModel.class)).collect(Collectors.toList());

        model.setCode(user.getCode());
        model.setCreatedDate(user.getCreatedDate().toString());
        model.setRoles(roleModels);
        model.setPassword(null);

        UserModel userModel = modelMapper.map(model, UserModel.class);

        UserResponseModel response = new UserResponseModel();
        response.setHttpStatus(HttpStatus.CREATED);
        response.setMessage("User created successfully.");
        response.setModel(userModel);

        return response;
    }

    @Override
    public UserResponseModel edit(UserModel model) {

        User entity = repository.findByCode(model.getCode()).orElseThrow(() -> new ResourceNotFoundException("User not found."));

        if (model.getName() != null)
            entity.setName(model.getName());

        if (model._getPassword() != null)
            entity.setPassword(passwordEncoder.encode(model._getPassword()));

        if (model.getState() != null)
            entity.setState(model.getState());

        if (model.getRoleCodes() != null && !model.getRoleCodes().isEmpty())
            entity.setRoles(addToleToUser(model.getRoleCodes()));

        entity.setEditedDate(LocalDate.now());

        UserResponseModel response = new UserResponseModel();
        response.setModel(model);
        response.setHttpStatus(HttpStatus.OK);

        return response;
    }

    @Override
    public UserResponseModel remove(String code) {

        repository.deleteByCode(code);

        UserResponseModel response = new UserResponseModel();
        response.setHttpStatus(HttpStatus.OK);
        response.setMessage("User removed successfully.");

        return response;
    }


    private UserResponseModel addRoleToUser(String username, String roleName) {

        User user = repository.findByUsername(username).orElseThrow(() -> new UsernameNotFoundException("User name not found"));
        ;

        if (user == null)
            throw new ResourceNotFoundException("User not found");

        Role role = roleRepository.findByName(roleName);

        if (role == null)
            throw new ResourceNotFoundException("Role not found");

        user.getRoles().add(role);

        UserResponseModel response = new UserResponseModel();
        response.setHttpStatus(HttpStatus.OK);
        response.setMessage("Role added to User successfully.");

        return response;
    }


    private Collection<Role> addToleToUser(Collection<String> roleCodes) {

        Collection<Role> roles = new ArrayList<>();

        if (roleCodes != null && !roleCodes.isEmpty()) {

            for (String roleCode : roleCodes) {

                roleRepository.findByCode(roleCode).ifPresent(roles::add);
            }
        }

        if (roles.isEmpty()) {
            Role role = roleRepository.findByName("ROLE_USER");
            roles.add(role);
        }


        return roles;
    }
}
