package com.sdase.malwarescanner.service.impl;

import com.sdase.malwarescanner.dto.FileResponseDTO;
import com.sdase.malwarescanner.entity.Check;
import com.sdase.malwarescanner.entity.File;
import com.sdase.malwarescanner.exception.FileDownloadException;
import com.sdase.malwarescanner.exception.ResourceNotFoundException;
import com.sdase.malwarescanner.exception.StorageException;
import com.sdase.malwarescanner.model.CheckEvent;
import com.sdase.malwarescanner.repository.CheckRepository;
import com.sdase.malwarescanner.repository.FileRepository;
import com.sdase.malwarescanner.repository.IFileSearch;
import com.sdase.malwarescanner.service.CheckProducerService;
import com.sdase.malwarescanner.service.FileService;
import com.sdase.malwarescanner.service.StorageService;
import com.sdase.malwarescanner.dto.FileRequestDTO;
import org.apache.tika.Tika;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.io.IOException;
import java.util.List;

import static com.sdase.malwarescanner.config.Constants.FILE_REST_CHECK_DOWNLOAD_ABSOLUTE_PATH;
import static com.sdase.malwarescanner.config.Constants.FILE_REST_CONSUMER_DOWNLOAD_ABSOLUTE_PATH;
import static com.sdase.malwarescanner.util.Checksum.getChecksum;
import static com.sdase.malwarescanner.util.UUIDUtil.getUUID;


@Service
public class FileServiceImpl implements FileService {

    private StorageService storageService;

    private CheckProducerService checkProducerService;

    private FileRepository repository;

    private CheckRepository checkRepository;

    private Tika tika;

    public FileServiceImpl(StorageService storageService, CheckProducerService checkProducerService, FileRepository repository, CheckRepository checkRepository, Tika tika) {
        this.storageService = storageService;
        this.checkProducerService = checkProducerService;
        this.repository = repository;
        this.checkRepository = checkRepository;
        this.tika = tika;
    }

    @Override
    public File getByCode(String code) {

        return repository.findByCode(code).
                orElseThrow(() -> new ResourceNotFoundException(String.format("Could not find file code: %s", code)));
    }

    @Override
    public FileResponseDTO getForChecking(FileRequestDTO model) {

        File file = getByCode(model.getCode());

        // A file just can be downloaded by specific check service once.
        isFileAlreadyDownloadedBySpecificCheck(file, model.getCheckName());

        Check check = new Check();
        check.setName(model.getCheckName());
        check.setFile(file);
        check.setState(Check.State.CHECKING);

        checkRepository.save(check);

        return new FileResponseDTO().
                setPublicFileName(generateName(file.getCode() , file.getFileType())).
                setResource(storageService.loadAsResource(file.getName())).
                setContentType(file.getFileType());
    }

    @Override
    public FileResponseDTO getForConsuming(String code) {

        File file = getByCode(code);

        // Only files which passed check process can be downloaded
        isCheckProcessDoneByCheckServices(file);

        return new FileResponseDTO().
                setOriginalFileName(file.getOriginalName()).
                setResource(storageService.loadAsResource(file.getName())).
                setContentType(file.getFileType());
    }

    @Override
    public List<IFileSearch> getAllByFileStateAndCheckState(File.State fileState, Check.State checkState) {
        return repository.findAllByFileStateAndCheckState(fileState, checkState);
    }

    @Override
    public void add(MultipartFile multipartFile) {

        String sha256 = getChecksum(multipartFile);

        // File must be uploaded once
        isFileAlreadyUploaded(sha256);

        String contentType = extractFileContentType(multipartFile);
        String name = generateName(getUUID() , contentType);

        storageService.store(name, multipartFile);


        String originalName = StringUtils.cleanPath(multipartFile.getOriginalFilename());

        File file = new File();
        file.setCode(getUUID());
        file.setSha256(sha256);
        file.setName(name);
        file.setOriginalName(originalName);
        file.setFileType(contentType);
        file.setState(File.State.UPLOADED);

        repository.save(file);

        String url = getFileURLForChecking(file.getCode());

        checkProducerService.produce(new CheckEvent().setFileType(multipartFile.getContentType()).setUrl(url));
    }

    @Override
    public void addOrEdit(File entity) {
        repository.save(entity);
    }

    @Override
    public void addOrEdit(List<File> entities) {
        repository.saveAll(entities);
    }

    @Override
    public void delete(String name) {
        storageService.delete(name);
    }

    @Override
    public String getFileURLForChecking(String code) {
        return generateURL(FILE_REST_CHECK_DOWNLOAD_ABSOLUTE_PATH, code);
    }

    @Override
    public String getFileURLForConsuming(String code) {
        return generateURL(FILE_REST_CONSUMER_DOWNLOAD_ABSOLUTE_PATH, code);
    }


    private String generateURL(String path, String code) {
        return ServletUriComponentsBuilder.fromCurrentContextPath().path(path).path(code).toUriString();
    }


    private String extractFileContentType(MultipartFile multipartFile) {
        try {
            return tika.detect(multipartFile.getBytes());
        } catch (IOException e) {
            throw new StorageException("Cannot store file with unknown type.");
        }
    }


    private String generateName(String name , String contentType) {
        String absoluteName = "%s.%s";
        String fileExtension = contentType.substring(contentType.lastIndexOf("/") + 1);
        return String.format(absoluteName, name, fileExtension);
    }


    private void isFileAlreadyUploaded(String sha256){
        if (repository.findBySha256(sha256).isPresent())
            throw new StorageException("This file already exists.");
    }


    private void isFileAlreadyDownloadedBySpecificCheck(File file, String checkName) {
        if (checkRepository.findByNameAndFile(checkName, file).isPresent())
            throw new FileDownloadException(String.format("File: %s is already downloaded by: %s", file.getCode(), checkName));

    }


    private void isCheckProcessDoneByCheckServices(File file){
        if (file.getState() != File.State.OK)
            throw new FileDownloadException(String.format("File: %s is checking and it's not ready to download.", file.getCode()));
    }

}