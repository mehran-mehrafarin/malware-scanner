# Architectural Overview

## 1. Components

The malware-scanner is built upon two different types of components:

- facade
- check

![Architectural overview](malware-scanner-architecture.png)

### 1.1. Facade

The facade serves as an interface to other services of the SDA platform to scan
files for malware. Externally, it simplifies the use of the malware scanner. Internally, it protects
the knowledge of how to use the individual checks of the malware scanner.

The facade coordinates the scan subcomponents malware checks. It knows in
which order or under which conditions the subcomponents must be called and aggregates the individual
results to an overall result. Following the SDA microservice architecture principles, it does not
implement its own checks, but delegates them to their own malware check services.

The malware-scanner facade is intended to simplify the use of the service. It is responsible for
making the files available to the individual checks.

On top of that the facade is responsible for persisting the scan details because

- scanning might take longer and we need to keep the state of the scan for the consumer.
- a restart of the service should be possible without losing scan jobs

The facade is designed to achieve the nonfunctional requirements like performance, as we expect
many files to be scanned.

### 1.2. Check

We distinguish between synchronous and asynchronous checks.

#### 1.2.1. Synchronous check

The synchronous checks can be understood as the first security hurdle. They protect subsequent checks
against obviously corrupt files. The execution order is thus determined: First synchronous, then
asynchronous. The execution time of the synchronous checks must be relatively short (preferably instantly).

#### 1.2.2. Asynchronous check

The asynchronous checks perform time-consuming operations on files provided by the facade.

## 2. Sequence Diagram

n/a

## 3. Communication

The facade and the checks shall not be able to access the public internet (although checks might
be allowed to update their virus signature). Only the facade shall be exposed to other SDA services.

### 3.1. Consumer <> Facade

The facade is an SDA Business Service providing a REST API to other SDA services. The publication of
the scan result is realized asynchronously using a Kafka topic.

### 3.2. Facade <> synchronous checks

Synchronous checks provide a suitable REST API. The result is returned synchronously to the facade.

### 3.3. Facade <> asynchronous checks

Communication between the facade and the asynchronous checks should be implemented using Apache Kafka.
The facade produces a message into a configured topic and all of the asynchronous checks consume this event once.
This is solved by using kafka's consumer-groups, where each check is a consumer-group.
After the check has processed the event, it publishes a new event into the result topic, being
ultimately consumed by the facade.

#### 3.3.1. Trigger Check

[Streaming Model of 'CheckEvent'](src/main/java/com/sdase/malware/scanner/streaming/model/CheckEvent.java)

#### 3.3.2. Send check result

[Streaming Model of 'CheckResultEvent'](src/main/java/com/sdase/malware/scanner/streaming/model/CheckResultEvent.java)

##  4. File Handling

### 4.1. Facade

The facade will get the file within the body as part of the request from the service consumer. The
facade takes care of limiting the file size. The file will be stored in an s3 compatible storage.
To access the file from the s3 storage the facade provides two endpoints:
- An endpoint for the consumer to download the file after the scan completed and no suspicious content was detected.
- An (internal only) endpoint for the checks to get the file they need to inspect.

The file is stored with the `<scanUUID>` generated by the facade and the original extension.
The original filename along with the `<scanUUID>` needs to be stored by the facade within a
persistence layer (e.g. Mongo db).

_Security notes_:

- The original filename is not used to store the file in the filesystem because it already
  might be used as an attack (e.g. path traversal).
- It's good to use a random UUID and not an incrementing identifier because it's harder
  to guess for attackers.
- Access to the scan endpoint of the facade is protected by
    - the request needs a `Consumer-Token` header that identifies the service
    - the request needs a valid JWT as bearer token of the `Authorization` header
- It is planned to use rate limiting to prevent the guessing of a random UUID.
  A check is only supposed to request a single download of the file with it's known UUID.
  If a check tries to request multiple files or an unknown file, further requests by that check shall be denied.

The file content will be deleted
- if the scan showed it is suspicious

### 4.2. Checks

_This is only relevant for checks which verify the binary data of the file (not only the filename)._

Checks use an endpoint of the facade to request the file they need to check for the scan.

## 5. REST API

The API is exposed by Swagger. You can access it locally by starting the application:

- build the application: `./gradlew :malware-scanner-service:jibDockerBuild`
- run the docker image: `docker-compose up`
- retrieve swagger file in your browser: [http://localhost:8500/api/swagger.json](http://localhost:8500/api/swagger.json)
- alternatively show in SwaggerUI: [https://petstore.swagger.io?url=http://localhost:8500/api/swagger.json](https://petstore.swagger.io?url=http://localhost:8080/api/swagger.json)

### 5.1. Asynchronous REST API

When requesting a new scan the API does not respond with the scan result immediately, but with HTTP
status `200 Ok`. The caller will be notified when the scan is finished by listening to a configurable
Kafka topic.

### 5.2. Scan Results

[Streaming Model of ScanResult](src/main/java/com/sdase/malware/scanner/api/streaming/model/ScanResult.java)

Furthermore the record will contain a header `requester_service` which contains the value of the
`Consumer-Token` header of the request that started the scan.

Scan results should not be cached by the service consumer since the outcome of the scan can change
over time, e.g. because virus signatures are updated from time to time.
